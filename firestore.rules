/**
 * This ruleset enforces a strict security model for a Family Finance Tracker application.
 *
 * Core Philosophy:
 * The security model is built on two primary concepts:
 * 1. User Data Isolation: All personal financial data is strictly private and scoped to the user who created it.
 * 2. Role-Based Access Control (RBAC): A separate `roles_admin` collection grants administrative privileges for managing public data and viewing user data for support purposes.
 *
 * Data Structure:
 * - /users/{userId}: The root path for all user-specific data, including their profile.
 * - /users/{userId}/transactions: Subcollection for a user's general financial transactions.
 * - /users/{userId}/wiseTransactions: Subcollection for a user's Wise-specific transactions.
 * - /exchangeRates: A top-level collection for publicly readable exchange rate data.
 * - /roles_admin: A top-level collection used as a lookup table to identify administrators.
 *
 * Key Security Decisions:
 * - Path-Based Ownership: All user-private subcollections (`transactions`, `wiseTransactions`) rely on the `/users/{userId}` path for authorization, ensuring users can only access their own data tree. This is simple, performant, and secure.
 * - Admin Privileges: The existence of a document at `/roles_admin/{userId}` grants the user admin rights. Admins are granted read-only access to user data and full control over public collections like `exchangeRates`.
 * - No Client-Side Role Management: The `roles_admin` collection cannot be modified by any client to prevent self-escalation of privileges. It must be managed via the Firebase Console or a trusted backend server.
 * - Public Data Segregation: Publicly accessible data (`exchangeRates`) is stored in a separate top-level collection. This allows for safe and efficient public `list` operations without exposing any private user information.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the foundation of the ownership model.
     * @param userId The user ID to check against the request's authentication UID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if a document exists AND the requester is the owner.
     * Used for safe update and delete operations.
     * @param userId The user ID to check for ownership.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the requesting user has administrative privileges.
     * This is determined by the existence of a document in the /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    // --------------------------------------------------------------------
    // User Data Collections
    // --------------------------------------------------------------------

    /**
     * @description Manages user profile documents. Allows users to create and manage their own profile, and allows admins to view profiles.
     * @path /users/{userId}
     * @allow A user creates their own profile document: auth.uid = 'user123', (create) on /users/user123.
     * @deny A user tries to update another user's profile: auth.uid = 'user123', (update) on /users/user456.
     * @principle Enforces Self-Creation and Ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures a user's private financial transactions. Only the owner can manage their data. Admins have read-only access.
     * @path /users/{userId}/transactions/{transactionId}
     * @allow A user creates a transaction for themselves: auth.uid = 'user123', (create) on /users/user123/transactions/tx456.
     * @deny A user tries to read another's transaction list: auth.uid = 'user123', (list) on /users/user456/transactions.
     * @principle Restricts access to a user's own data tree (Path-based Ownership).
     */
    match /users/{userId}/transactions/{transactionId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures a user's private Wise transactions. Only the owner can manage their data. Admins have read-only access.
     * @path /users/{userId}/wiseTransactions/{wiseTransactionId}
     * @allow A user updates their own Wise transaction: auth.uid = 'user123', (update) on /users/user123/wiseTransactions/wtx789.
     * @deny An admin tries to delete a user's transaction: auth.uid = 'admin_user', (delete) on /users/user123/wiseTransactions/wtx789.
     * @principle Restricts access to a user's own data tree (Path-based Ownership).
     */
    match /users/{userId}/wiseTransactions/{wiseTransactionId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    // --------------------------------------------------------------------
    // Public & Admin Collections
    // --------------------------------------------------------------------

    /**
     * @description Manages global exchange rate data. This data is public for all to read, but only admins can create, update, or delete it.
     * @path /exchangeRates/{exchangeRateId}
     * @allow Any user (signed in or not) reads an exchange rate: (get) on /exchangeRates/brl-eur-2023.
     * @deny A non-admin user tries to create a new exchange rate: auth.uid = 'user123', (create) on /exchangeRates/usd-eur-2024.
     * @principle Implements a "Public Read with Admin-Only Writes" security model.
     */
    match /exchangeRates/{exchangeRateId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Defines which users have admin privileges. This collection is read-only for admins and fully locked down for writes from any client.
     * @path /roles_admin/{userId}
     * @allow An admin checks if another user is also an admin: auth.uid = 'admin_user', (get) on /roles_admin/other_admin.
     * @deny Any client-side user tries to create an admin role: auth.uid = 'hacker_user', (create) on /roles_admin/hacker_user.
     * @principle Disallows client-side modification of critical access control data to prevent privilege escalation. Roles must be managed server-side.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

  }
}